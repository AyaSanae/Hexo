---
title: C语言-字节对齐
date: 2020-05-07 12:51
categories:
    C
tags:
    C
cover: /assets/c_byte.jpg
comments: true

---

{% aplayer name="東方萃夢想" artist="みなも" url="/music/东方萃梦想/东方萃梦想.mp3" lrc="" cover="/music/东方萃梦想/cover.jpg" %}

## 引言
来看下面这段代码
```
#include<stdio.h>
struct i
{
    int a;
    char b;
    float c;
};
int main()
{
    int d;
    char e;
    float f;
    printf("%d\n",sizeof(struct i));
    printf("int=%d\nchar=%d\nfloat=%d\n",sizeof(d),sizeof(e),sizeof(f));
    return 0;
}
```
input:
```
12
int=4
char=1
float=4
```
这时发现结构体i的大小跟变量d,e,f的和是不同的.

## Why?
现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

## 为什么要对齐
为了尽可能高的提高CPU访问速率. 
设一枚处理器每次只能从存储器中读取4byte的数据,那么地址就要是4的倍数,如果可以保证这个,那么一次即可读出或写入数据,否则可能要进行多次访问,因为数据可能被存储在多个存储器中.
设一枚64位处理器通过总线访问存储器数据,那么每个总线周期从偶地址开始访问64位内存数据,则一个64位的数据没有存放在8字节倍数的内存地址处，那么处理器就需要2个总线周期对其进行访问,两个周期肯定比一个周期慢.
所以,通过字节对齐,可以将内存地址填充到对应的倍数,这样就可以一个周期访问.

## 结构体对齐
回到引言
```
struct i
{
    int a;
    char b;
    float c;
};
```
int 4字节,char 1字节,float 4字节,结构体总大小为9字节
但是sizeof(struct i)的返回值是12
也就是说,已经被字节对齐了,这里可以发现,字节对齐实际上就是:
“用空间换时间.”

## 对齐方式
1. 数据类型自身的对齐值:

| 类型        | 16位 | 32位 | 64位 |
| :-------------: | :----: | :----: | :----: |
| char          | 1    | 1    | 1    |
| short int     | 2    | 2    | 2    |
| int           | 2    | 4    | 4    |
| unsigned int  | 2    | 4    | 4    |
| float         | 4    | 4    | 4    |
| double        | 8    | 8    | 8    |
| long          | 4    | 4    | 8    |
| long long     | 8    | 8    | 8    |
| unsigned long | 4    | 4    | 8    |
2. 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值.
3. 指定对齐值：#pragma pack (value)时的指定对齐值value.
4. 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}.

基于上面这些值，就可以方便地讨论具体数据结构的成员和其自身的对齐方式。
其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。

结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则：

1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；

2. 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；

3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。

对于以上规则的说明如下：

第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的
对齐模数。

第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。

第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。

参考文章:
> https://blog.csdn.net/cclethe/article/details/79659590
> https://www.cnblogs.com/clover-toeic/p/3853132.html
> https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/1634057?fr=aladdin


















