---
title: CPU调速器及I/O调度详解
subtitle:
date: 2020-06-21 16:15
comments: true
categories:
    - Kernel
tags:
    - Kernel
    - Android
cover: /assets/governor.jpg

---
【ondemand】按需模式:→按需调节cpu频率,不操作手机的时候控制在最低频率,滑屏或进入应用后会迅速提升至最高频率,当空闲时迅速降低频率,性能较稳定,但因频率变化幅度过大,省电方面只有一般的水平。是一种在电池和性能之间趋向平衡的默认模式,但是对于智能手机来说,ondemand在性能表现方面略有欠缺。

【interactive】交互模式:→和ondemand相似,规则是“快升慢降”,注重响应速度、性能,当有高需求时迅速跳到高频率,当低需求时逐渐降低频率,相比ondemand费电

【conservative】保守模式:→和ondemand相似,规则是“慢升快降”,注重省电,当有高需求时逐渐提高频率,当低需求迅速跳至低频率。

【OndemandX】按需X模式:→在Ondemand基础上改进而来。关屏时手机进入睡眠状态时,锁定最高频率频率为500Mhz

【Scary】胆小模式:→基于Ondemand修改,CPU提升速度比ondemand慢,同时具有smartass的特点

【interactiveX】交互X模式:→在interactive基础上改进而来。关屏时手机进入睡眠状态时,锁定频率为最低值,同时在手机唤醒时能有更好的提升表现。比interactive更注重保护电池。

【Wheatley】惠特利模式:→规则和Ondemand一样,但是响应速度稍慢,比Ondemand省电

【hotplug】热拔插模式:→和ondemand模式差不多,当有高需求时直接跳到最高频率,当需求见效时逐级降低频率,但关屏时就单核低频运行,省电。

【lionheart】狮心模式:→基于conservative模式,但性能有所提高,增快了CPU的调整速度

【lulzactive】级别模式:→在interactive基础,根据负载逐级升高或降低频率,每一级频率有一个限制值,负载高于限制值就提高一级频率,低于限制值就降低一级频率。所以这个调速器在各个频率上的停留时间都很短。这个调速器的特点是在各个频率之间频繁变动,但是运行于最高和最低频的时间最多。

【smartass】聪明模式:→是interactive和conservative的升级,根据资源使用智能提供一个适中的频率,空闲时自动降频,锁屏时自动固定频率。特色是锁屏后非常省电。缺点是部分机型锁屏一段时间后容易睡死。

【smartassV2】聪明2模式:→smartass的升级版,平衡效能和耗电,升频快,降频慢,同时间亦会于锁屏时将频率降到最低,集成了休眠策略,不单单是指关了屏幕和开着屏幕的区别。

【smoothass】活跃模式:→在smartass基础上改进得来的,性能更高,调节速度更快,耗电少

【SavagedZen】平衡模式→在smartass的基础优化而来,同时注重电池和性能,使CPU达到一个更好的整体平衡

【BrazilianWax】巴兹拉模式:→基本就和smoothass一样

【Minmax】大小模式:→基于conservative的优化版,类似smartassV2,速度性能最好,比smartassV2略微耗掉

【intellidemand】智能模式:→可根据GPU使用情况来针对性调节cpu频率,当GPU于重度使用时 ,所有动作都依照ondemand 不变。当3GP于闲置时,会自动限制cpu最高频率,将CPU最高频率锁死于1.0Ghz以减少耗电。关屏时亦会视乎 GPU 情况而作出调整。

【Pegasusq】单控模式:→源自三星猎户座处理器的一个调速器,可以单独调控单个CPU内核,理论上性能不错也很省电。

【badass】分工模式:一个新型的CPU调速器,只能用于多核CPU,可分开控制单个CPU内核,来分工完成不同的工作,并且跟着工作量的不同,分别调整单个CPU内核的频率,从而提高性能,节省资源。这个模式现在好像只能用在特定修改的rom中

【performance】高性能模式:→高性能模式,按你设定范围的最高频率运行,即使系统负载非常低cpu的频率也为最高。性能很好,因为CPU本身不需要资源去调整频率,但是电量消耗较快,温度也高一些。

【powersave】省电模式:→按设定最低频率运行,日常没有使用价值,除非配合setcpu情景模式,关屏睡眠时使用此调节模式,省电但系统响应速度慢。

【userspace】用户模式:→任何情况下都会控制CPU运行在配置的频率范围内,配置中的用户自己添加的省电设置。在此情景模式下,降低CPU最大运行频率可以延长电池待机时间,但同时也会降低机器的唤醒速度,建议最好不使用该选项。

【lagfree】无延迟模式:→很少用的调速器,不紧不慢型,无论负载变化快慢与否,CPU都按一定的停顿时间逐级升高或降低频率。

【lazy】懒惰模式:→与 ondemand 相似,对于频率上升和下降的响应都很迟缓,可以忽略掉部分迅速变化的频率变化,优点是省电。

I/O调度模式：（i/o即input/output的缩写，关于数据的读写操作，不同进程请求数据的优先顺序等等。io调度模式比较复杂，我没有具体测试，这里仅对ray上出现的几个模式做说明，部分参考xda、androidforums、wik1pedia、linuxarchive资料）noop这个调度模式会把所有的数据请求直接合并到一个简单的队列里。不适合有机械结构的存储器，因为没有优化顺序，会增加额外的寻道时间。属于最简单的一个调度模式，无视io操作优先级和复杂性，执行完一个再执行一个，如果读写操作繁多的话，就会造成效率降低。anticipatory其实这个有点类似于pc硬盘的NCQ功能，执行有预测性的调度，看起来似乎可以提高效率，不过因为它的预测机制会在进程将要结束一个读写操作时时开始准备下一个的预处理，所以会打乱系统正常的连续io调度，降低随机存取效率。用的人很少，不推荐。deadline顾名思义，用过期时间来排序io操作顺序，保证先出现的io请求有最短的延迟时间，相对于写操作，给读操作更优先的级别。是比较好的一个调度模式。cfq完全公平队列，是anticipatory模式的替代品，没有过多的做预测性调度，而是根据给定的进程io优先级，直接来分配操作的顺序。这个模式在linux上表现良好，但也许并不是最适合android的io调度模式，太强调均衡，而降低了连续读写数据的性能。vr具有和deadline相似的操作排序机制，有着最高的峰值读写速度，但是性能比较不稳定，也就是说可能跑出最高的分数，但是也会出现最低值。sio虽然基于deadline，但是它和noop一样，不会对io操作进行排序，所以有着noop那样快速的存取速度，但并没有过多优化io操作。如果不喜欢noop完全不参与调度，也可以选择这个。

总体而言，推荐指数依次为sio=deadline(两种趋向，一种少干预，一种多干预)>vr(性能可以达到最高峰值)>cfq=noop>anticipatory